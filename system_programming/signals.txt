SIGNAL
 signal can be thought of as a software interrupt -> not a H/W intrpt(not eminating from H/W)
Signals are asynchronous and value of signals is integer

But trouble is it can
Then Ctrl C on keyboard? ->SIGINT(signal interrupt)-> sends  signal to fg process

Generate several h/w intrpt -> but high level -> which is taken care by driver code and tty layer inside linux kernel-> tty layer will work upon multiple keyboard scan code int one signal -> deliver to fg process.

Conclusion : do not confuse between h/w intrpt and signal -> they arent same -> even if some time seems to be


Buffer overfow->buffer underflow ->violated bounds of segment -> kernel detects memory violation -> send SIGSEGV to process -> segfault


To see available signal kill -l 
• The 1st 31 signals are the ‘UNIX’ signals / standard / POSIX.1
signals
• 32, 33 are reserved (Pthreads uses it)
• Signals from 31 – 64 are the Real-time signals-> (SIGRTn)-> OS must support POSIX.1b
– real-time extensions to POSIX
Console based app -> doing task -> copy to file -> Ctrl C  -> default action is kill -> loss, loose data ->need to handle signal

Ctrl C-> control goes in kernel -> default signal handler is in kernel -> kernel keeps it simple -> 4
	1. Ignore signal
	2. Stop  process
	3. Terminate process
	4. Emit core dump  

Often is termination -> SIGINT

We need to handle a signal
When process is initializing -> register signal handler with kernel
How to implement? -> using sys calls -> changes at kernel level

The letters in the "Action" column have the following meanings:
A Default action is to terminate the process.
B Default action is to ignore the signal.
C Default action is to terminate the process and dump core. 
D Default action is to stop the process.
E Signal cannot be caught.
F Signal cannot be ignored


SIGKILL 	9 	AEF	 Kill signal
SIGSTOP	 17,19,23	 DEF	 Stop process
SIGINT	 2 	A	 Interrupt from keyboard  ^C
SIGQUIT 	3	 C	 Quit from keyboard    ^\
SIGSEGV 	11 	C 	Invalid memory reference
SIGALRM	 14 	A 	Timer signal from alarm(2)                            Setup via timer -> Send when timeout
SIGCONT	 19,18,25		 Continue if stopped                                     Stopped?->not dead-> SIGCONT
SIGTSTP 	18,20,24 	D 	Stop typed at tty     ^Z->terminal stop
SIGUSR1	 30,10,16 	A 	User-defined signal 1                                   Not generated by OS ->its for application 
SIGUSR2 	31,12,17	 A	 User-defined signal 2
SIGHUP 	1	 A	 Hangup detected on controlling terminator death of controlling process [nohup(1)]
SIGTERM 	15	 A	 Termination signal                                    kill pid

Some signals has 3 nos -> arch specific -> middle is for x86 -> always use symbolic name & not number for portability

Pause and stop
Pause -> means process is sleeping -> send any signal -> it will awake
Process stopped? -> to continue -> send SIGCONT


SIGSEGV, SIGFPE are usually send by kernel to process -> can catch -> write own handler ->but can't continue
-> as wen process receives such signals process is in undefined state -> have to terminate -> unstable state-> have to handle such signals -> report why they came-> log.


Signal as IPC ? -> SIGUSR1 ->send signal from p1 to p2(some event notification) -> SIGUSR2 p2 to p1(ack) -> do not forget to change default action which is A.  

Can only send a signal to a process that you own; IOW, the sender and receiver (E)UIDs should match
Exception: root (UID==0) can send any signal to any process…



How to trap/ handle signal

1. signal(2)    -> older approach
2. sigaction(2)          -> new and powerful
3. sigvec()       -> deprecated

This apis registers our handlers with kernel, when signal arises handlers are fired.

sigaction sys call
int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);

int sig : signal to trap -> say SIGINT -> Do not bitwise OR with multiple signals -> not a bit mask -> its absolute value


struct sigaction
old
struct sigaction {
void (*sa_handler)(int);
sigset_t sa_mask;
int sa_flags;
}

New (linux that have RT support)
void (*sa_handler)(int);
void (*sa_sigaction)(int, siginfo_t *, void *);
sigset_t sa_mask; << allow other signals while in the handler?bit cleared => allow the signal bit set => block the signal >>
int sa_flags; // behavior control
void (*sa_restorer)(void);

1st nd 2nd are mutually exclusive-> either 1st or 2nd -> 2nd more powerful, more details from OS


3rd : signal mask -> bit mask -> every bit in bitmask represents a signal -> clearing particular bit will allow that signal while handling other signal ->  do not wish to allow -> set all bits of mask to 1
sa_mask = 1;          //wrong syntax(will set only LSB bit), must use available helper methods to manipulate  signal mask
			//sigemptyset(&act.sa_mask), sigfillset(&act.sa_mask);


4th: sa_flags -> bit mask -> for behavior control -> powerful -> do not want to use , set to 0.

5th : sa_restorer -> for internal use only , we can ignore it

Coming back to API
int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);
2nd parameter is new settings-> which you needs to populate -> by allocating new memory to ptr and then pass
3rd parameter -> to store current value of sigaction

One can perform store and restore (context switch)-> optional-> no context required? -> pass NULL or 0.


Just want to ignore some signal? -> do not wish to provide user defined handler? -> use macros -> @2nd para in sigaction
Macros ->   SIG_IGN : ignore the signal -> usecase -> SIGHUP ?? Ignore??; use SIG_IGN in sigaction()
		SIG_DFL : revert signal action to [g]libc default
		 


Dealing with async items? Like signals? -> give rise reentrancy issue -> write instead of printf

Every single function written can be -> reentrant safe or reentrant 

Never call functions which use global/static data from within a signal handler. Only functions explicitly documented as being reentrant-safe – or signal-async safe – can be called from within a signal handler.
In linux many existing library function falls in this category -> do not call them from signal handler
printf() -> signal-async unsafe -> why? uses static data
malloc() & friends –> use static data -> DON’T call them in signal handlers -> not safe.

Where its listed ? Documented? man signal-saftey(7), signal(7)
Vast majority of sys calls are safe, but many library calls are unsafe.



ltrace ps -> u can see lib calls on ps -> sigaction? -> on linux sigaction is lib wrapper which internally calls rt_sigaction(sys call)

Just like -> wait -> wait_foo  ->  exec -> exec_ve




sigaction(2) Flags


Zombie issue : if parent process does not issue wait()-> child dies and  becomes zombie -> remains zombie until parent calls wait()
(wait can be called later as well after child has died)

To avoid this issue -> call wait() -> but not good for performance -> defeats parallelism -> solve using signals

The OS guarantees that when a process dies (or stops or continues!) it’s parent will receive SIGCHLD .

Richard Stevens' "Advanced Programming in the UNIX Environment"

static void avoid_zombies(int signo)
{
int exit_status;
while (waitpid(-1, &exit_status, WNOHANG) > 0) {
/* do nothing */
}
}

if ((signo == SIGCHLD) && (func == SIG_IGN)) {
act.sa_handler = avoid_zombies;
}


waitpid passing -1 means -> wait on death of any process
WNOHANG -> do a non-blocking wait -> only clear dead zombies -> leave alone children that are alive
&exit_status -> pointer to bit mask
Y wait() over waitpid() -> wait() would be blocking as it will wait on live child process as well

Main thread -> fork 5 child -> 3 died -> becomes zombie -> parent process will receive SIGCHLD -> avoid_zombie handler will get control


With > 2.6 linux
SA_NOCLDWAIT
If signal is SIGCHLD, do not transform children into zombies when they terminate-> Zombies issue is done away 
-> no handler req
Kernel will internally will take care of zombie issue

if ((signo == SIGCHLD) && (func == SIG_IGN)) {
act.sa_flags |= SA_NOCLDWAIT;  
}

When parent in wait() -> wait() gets unblocked -> child dies or child stops or child continues(all will issue SIGCHLD )
SA_NOCLDSTOP
If signum is SIGCHLD, do not generate SIGCHLD when children stop or stopped children
continue.

The OS guarantees that when a process dies (or stops or continues!) it’sparent will receive SIGCHLD .
To prevent SIGCHLD when the child(ren) stop/cont, use the flag SA_NOCLDSTOP.

//signalling/zombie_clear*.c

SA_ONESHOT or SA_RESETHAND

Work user defined handler only once? Then use default kernel behavior -> SA_ONESHOT 
This was default behavior in old days with signal()



When a system call fails, the kernel sets the variable errno to a +ve integer. 
errno index into a _sys_errlist[] -> array of strings... all possible error messages.

perror() -> appends English error message corresponds to errno


SA_RESTART
If process issued sys call is blocking -> it goes to sleep -> while sleeping signal occur -> what to do?
	- Handle it?
	- Ignore it?
	- Handle later after awake
Have to handle when received.

Without SA_RESTART -> it use to handle and resume the sleep which use to fail returning -1 -> errno sets to EINTR.
Use SA_RESTART, not available with signal(old unix).   

act.sa_flag |= SA_RESTART;
sigaction();
...
if (syscall_foo() < 0) { // accept()
< ... > [errno -> EINTR; ]
perror(“it failed..”); / strerror()..
“Interrupted system call” => a signal interrupted a blocking API...
}

Thumb rule : duration of signal handler should be as small as possible

SA_NOMASK : if signal are realtime event we can't mask it
Signal occurred -> handling -> this signal is masked by default-> other signals there allowed by default-> sigfillset() 
For standard unix  signals
By default, while handling signal N, if ‘m’ occurrences of the same signal occur, then when handling’s done you will
receive only 1 signal N; N-1 instances are lost! IOW, the OS does NOT maintain a queue…

Kernel has Pending signal mask ->  signal that is occurred and not processed -> bit is set 
-> after handling complete -> kernel check this bit -> if set process the signal

To overcome use -> SA_NOMASK(work at a cost of stack memory)-> so use along with an alternate signal stack SA_ONSTACK
For every occurrence of signal -> one more stack frame gets allocated on user mode stack -> can be stack overflow

SA_NODEFER: don’t delay -> do it now
Handle signal immediately, don’t automatically blocks the signal when handler is executed

SA_NODEFER / SA_NOMASK to handle all signals as they occur! <--
real-time. Downside: heavy stack usage; what if your stack overflows!?

Solutions?
• use SA_NOMASK along with an alternate signal stack -> using the SA_ONSTACK flag
◦ typical upper limit on stack is 8 MB
◦ use sigaltstack(2) to get yourself a new stack for the express purpose of signal handling.
SA_ONSTACK : tells OS I will be heaving heavy stack usage -> allocate another memory in my virtual address as a stack
Linux has sys call  sigaltstack(2) for same.

• use real-time signals !
◦ while handling real-time signal N (one of the SIGRT*), if ‘m’ occurences of the same signal occur, then when handling’s done
you will receive ALL signals; the OS queues them!
▪ limit: on the length of the queue: prlimit |grep "SIGPENDING"
◦ the RT signals that are pending delivery to your process are
queued in a priority order: the order: SIGRTMIN is top prio,
SIGRMAX is lowest prio

prlimit  utility -> prints limit ->shows resource limit  per process bases -> soft limit -> hard limit(ignore this)





SA_SIGINFO
If cleared -> void func(int signo);
If set -> void func(int signo, siginfo_t *info, void *context);

/usr/include/x86_64-linux-gnu/bits/siginfo.h
...
typedef struct
{
int si_signo; /* Signal number. */
int si_errno; /* If non-zero, an errno value associated with this signal(what cause this signal to occur), as defined in <errno.h>. */
int si_code; /* Signal code. */
Union{ /* union of different structures-> depending upon what made signal to occur that particular struct will be populated*/}
}

si_code value Signal Origin
SI_USER kill, sigsend or raise
SI_KERNEL the kernel
SI_QUEUE sigqueue
SI_TIMER timer expired
SI_MESGQ mq state changed
SI_ASYNCIO AIO completed
SI_SIGIO queued SIGIO



typedef union sigval
{
int sival_int;
void *sival_ptr;
} sigval_t;
We can see that this allows our programs to pass data (either an integer or a generic pointer)
via signals!

